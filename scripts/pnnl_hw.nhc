# PNNL NHC - Hardware Checks
#
# Ken Schmidt <kenneth.schmidt@pnnl.gov>
# 16 June 2020
#

PNNL_HW_ETH_LINK=( )
PNNL_HW_ETH_RATE=( )
PNNL_HW_ETH_DEV=()

# Read hardware information from /proc and /sys files.
function pnnl_hw_gather_eth_data() {
    local LINE CORES SIBLINGS MHZ PROCESSOR PHYS_ID PORT INDEX DEV
    local -a FIELD PHYS_IDS IBPORTS

    # Gather IP info
    set +o noglob
    IBPORTS=( /sys/class/net/* )
    set -o noglob
    for PORT in "${IBPORTS[@]}"; do
        test -e "$PORT" || break
        INDEX=${#PNNL_HW_ETH_LINK[*]}
        read LINE < $PORT/carrier 2> /dev/null
        if [[ $LINE == 1 ]]; then
            PNNL_HW_ETH_LINK[$INDEX]=up
        else
            PNNL_HW_ETH_LINK[$INDEX]=down
        fi
        read LINE < $PORT/speed 2> /dev/null
        PNNL_HW_ETH_RATE[$INDEX]=$LINE
        IFS=' /'
        arr=( $PORT )
        PNNL_HW_ETH_DEV[$INDEX]="${arr[4]}"
        IFS=$' \t\n'
        dbg "Found IP Port ${PNNL_HW_ETH_DEV[$INDEX]} state (${PNNL_HW_ETH_LINK[$INDEX]}) (${PNNL_HW_ETH_RATE[$INDEX]} mb/sec)"
    done
    export PNNL_HW_ETH_DEV PNNL_HW_ETH_LINK PNNL_HW_ETH_RATE
}

# Check if ETH state, phys_state, and rate ($1) all match.
function check_hw_eth_status() {
    local RATE="$3"
    local LINK="$2"
    local DEV="$1"
    local i

    if [[ ${#PNNL_HW_ETH_LINK[*]} -eq 0 ]]; then
	dbg "gathering ethernet data"
        pnnl_hw_gather_eth_data
    fi

    for ((i=0; i < ${#PNNL_HW_ETH_DEV[*]}; i++)); do
        if [[ "${PNNL_HW_ETH_DEV[$i]}" == "$DEV" && "${PNNL_HW_ETH_LINK[$i]}" == "$LINK" ]]; then
            if [[  -z "$RATE" || "${PNNL_HW_ETH_RATE[$i]}" == "$RATE" ]]; then
                return 0
            fi
        fi
    done

    if [[ -n "$RATE" ]]; then
        RATE=" ($RATE Gb/sec)"
    fi

    die 1 "$FUNCNAME:  No ETH port $DEV is $LINK$RATE."
    return 1
}

function check_hw_kernel_module() {
    local MOD=$1
    local i

    if [[ ${#HW_MODULES[*]} -eq 0 ]]; then
        nhc_hw_gather_data
    fi

    for ((i=0; i < ${#HW_MODULES[*]}; i++)); do
        if [[ ${HW_MODULES[$i]} == $MOD ]]; then
            return 0
        fi
    done

    die 1 "$FUNCNAME:  $MOD kernel module not loaded."
    return 1
}

function check_rasdaemon() {
    local CE_THRESHOLD=$1
    local UE_THRESHOLD=$2
    local output ce_count ue_count
    output=$(ras-mc-ctl --error-count)

    ce_count=$(echo "$output" | awk 'NR>1 {ce+=$2} END {print ce+0}')
    ue_count=$(echo "$output" | awk 'NR>1 {ue+=$3} END {print ue+0}')

    if [[ $ce_count -gt $CE_THRESHOLD || $ue_count -gt $UE_THRESHOLD ]]; then
        die 1 "$FUNCNAME:  MEMORY ERRORS DETECTED.  CE_ERRORS: $ce_count  | UE_ERRORS: $ue_count"
    fi

    return 0
}

function check_smartctl_health() {
    local DEV="/dev/nvme0n1"
    local output status

    output=$(smartctl -H "$DEV" 2>&1)
    status=$(echo "$output" | awk '/SMART overall-health self-assessment test result/ {print $NF}')

    if [[ "$status" != "PASSED" ]]; then
        die 1 "$FUNCNAME:  SMART health check FAILED for $DEV. Status: $status"
    fi

    return 0
}

function check_cpu_speed() {
    local DRIVER_EXPECTED="$1"
    local driver_file driver_found=0
    local files

    shopt -s nullglob
    files=(/sys/devices/system/cpu/cpu*/cpufreq/scaling_driver)
    shopt -u nullglob

    if [[ ${#files[@]} -eq 0 ]]; then
        die 1 "$FUNCNAME: No scaling_driver files found under /sys/devices/system/cpu/"
    fi

    for driver_file in "${files[@]}"; do
        if [[ -f "$driver_file" ]]; then
            driver=$(cat "$driver_file")
            if [[ "$driver" != "$DRIVER_EXPECTED" ]]; then
                die 1 "$FUNCNAME: CPU scaling driver is '$driver' (expected '$DRIVER_EXPECTED') in $driver_file"
            else
                driver_found=1
            fi
        fi
    done

    return 0
}
